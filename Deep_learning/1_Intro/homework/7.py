import torch
import numpy as np

# Задаём количество признаков (фичей) и количество объектов в нашей модели
n_features = 2
n_objects = 300

# Генерируем истинные веса для нашей модели. Они случайны и следуют нормальному (гауссовскому) распределению.
w_true = torch.randn(n_features)

# Создаём матрицу объектов X. Размер матрицы - это (n_objects x n_features). 
# Мы вычитаем 0.5, чтобы центрировать данные вокруг 0, а затем умножаем на 5, чтобы получить более широкий диапазон значений.
# Это делается для того, чтобы сделать данные более "интересными" и сложными для модели.
X = (torch.rand(n_objects, n_features) - 0.5) * 5

# Сгенерируем "истинные" значения y, используя линейное преобразование наших объектов с истинными весами. 
# Затем добавляем нормальный шум, поделенный на два. 
# Это делается для того, чтобы внести некоторое количество случайности и непредсказуемости в наши данные, сделать их более "реалистичными".
Y = X @ w_true + torch.randn(n_objects) / 2



'''
- Инициализируем веса как в прошлом задании
- Пока ошибка больше заданного уровня вычисляем ошибку
- Вычисляем градиенты (обратное распространение)
- Обновляем веса (не забывая отключать подсчет градиентов)
- Обновляем параметры
- Включаем подсчет градиентов
'''

import torch

def function03(x: torch.Tensor, y: torch.Tensor):
    # Количество признаков
    n_features = x.shape[1]
    
    # Инициализируем веса
    w = torch.randn(n_features, requires_grad=True)
    
    # Параметры обучения
    learning_rate = 1e-2
    tolerance = 1e-1
    max_iter = 1000
    loss = torch.tensor(float('inf'))
    
    # Градиентный спуск
    for i in range(max_iter):
        # Вычисляем ошибку
        y_pred = x @ w
        loss = torch.mean((y - y_pred)**2)
        
        if loss.item() < tolerance:
            break

        # Вычисляем градиенты
        loss.backward()
        
        # Отключаем подсчет градиентов для обновления весов
        with torch.no_grad():
            w -= learning_rate * w.grad
        
        # Включаем подсчет градиентов и обнуляем градиенты
        w.grad.zero_()

    return w
